// Generated using `moon info`, DON'T EDIT IT
package "iceBear67/miao/codec/http"

import(
  "iceBear67/miao/buffer"
  "iceBear67/miao/io"
)

// Values
fn build_query_string(Map[String, Array[String]]) -> String

fn parse_cookie_header(String) -> Map[String, String]

fn parse_set_cookie(String) -> Cookie?

fn url_decode(String) -> String

fn url_encode(String) -> String

// Errors

// Types and methods
pub struct Cookie {
  name : String
  value : String
  domain : String?
  path : String?
  expires : String?
  max_age : Int?
  secure : Bool
  http_only : Bool
  same_site : SameSite?
}
fn Cookie::new(String, String) -> Self
fn Cookie::to_set_cookie_string(Self) -> String
fn Cookie::with_domain(Self, String) -> Self
fn Cookie::with_expires(Self, String) -> Self
fn Cookie::with_http_only(Self, Bool) -> Self
fn Cookie::with_max_age(Self, Int) -> Self
fn Cookie::with_path(Self, String) -> Self
fn Cookie::with_same_site(Self, SameSite) -> Self
fn Cookie::with_secure(Self, Bool) -> Self

pub struct HttpChunkedReader {
  reader : &@io.Reader
  mut current_chunk_remaining : Int
  mut finished : Bool
  mut trailer_headers : HttpHeaders?
}
fn HttpChunkedReader::is_finished(Self) -> Bool
fn HttpChunkedReader::new(&@io.Reader) -> Self
async fn HttpChunkedReader::read_all(Self) -> Bytes
fn HttpChunkedReader::trailer_headers(Self) -> HttpHeaders?

pub struct HttpChunkedWriter {
  writer : &@io.Writer
}
fn HttpChunkedWriter::new(&@io.Writer) -> Self
async fn HttpChunkedWriter::write_chunk(Self, Bytes) -> Unit
async fn HttpChunkedWriter::write_final_chunk(Self, HttpHeaders?) -> Unit

pub struct HttpContentReader {
  reader : &@io.Reader
  content_length : Int
  mut bytes_read : Int
}
fn HttpContentReader::bytes_read(Self) -> Int
fn HttpContentReader::content_length(Self) -> Int
fn HttpContentReader::has_more(Self) -> Bool
fn HttpContentReader::new(&@io.Reader, Int) -> Self
async fn HttpContentReader::read(Self, Int) -> Bytes
async fn HttpContentReader::read_all(Self) -> Bytes

pub struct HttpHeaders {
  headers : Array[(String, String)]
}
fn HttpHeaders::add(Self, String, String) -> Unit
fn HttpHeaders::get(Self, String) -> String?
fn HttpHeaders::get_all(Self, String) -> Array[String]
fn HttpHeaders::length(Self) -> Int
fn HttpHeaders::new() -> Self
fn HttpHeaders::remove(Self, String) -> Unit

pub(all) enum HttpMethod {
  GET
  POST
  PUT
  DELETE
  HEAD
  OPTIONS
  PATCH
  CONNECT
  TRACE
}
fn HttpMethod::from_string(String) -> Self raise
fn HttpMethod::to_string(Self) -> String
impl Eq for HttpMethod
impl Show for HttpMethod

pub struct HttpReader {
  reader : &@io.Reader
}
fn HttpReader::new(&@io.Reader) -> Self
async fn HttpReader::read_request(Self) -> HttpRequest
async fn HttpReader::read_response(Self) -> HttpResponse

pub struct HttpRequest {
  http_method : HttpMethod
  uri : String
  version : HttpVersion
  headers : HttpHeaders
  content_reader : HttpContentReader?
}
fn HttpRequest::content_reader(Self) -> HttpContentReader?
fn HttpRequest::method(Self) -> HttpMethod
fn HttpRequest::new(HttpMethod, String, HttpVersion) -> Self

pub struct HttpResponse {
  version : HttpVersion
  status : HttpStatus
  headers : HttpHeaders
  content_reader : HttpContentReader?
}
fn HttpResponse::new(HttpVersion, HttpStatus) -> Self

pub struct HttpStatus {
  code : Int
  reason : String
}
fn HttpStatus::bad_request() -> Self
fn HttpStatus::created() -> Self
fn HttpStatus::forbidden() -> Self
fn HttpStatus::internal_server_error() -> Self
fn HttpStatus::new(Int, String) -> Self
fn HttpStatus::no_content() -> Self
fn HttpStatus::not_found() -> Self
fn HttpStatus::ok() -> Self
fn HttpStatus::unauthorized() -> Self
impl Eq for HttpStatus
impl Show for HttpStatus

pub(all) enum HttpVersion {
  HTTP_1_0
  HTTP_1_1
}
fn HttpVersion::from_string(String) -> Self raise
fn HttpVersion::to_string(Self) -> String
impl Eq for HttpVersion
impl Show for HttpVersion

pub struct HttpWriter {
  writer : &@io.Writer
}
fn HttpWriter::new(&@io.Writer) -> Self
async fn HttpWriter::write_request(Self, HttpRequest, &@buffer.Buffer) -> Unit
async fn HttpWriter::write_response(Self, HttpResponse, &@buffer.Buffer) -> Unit
impl @io.Writer for HttpWriter

pub enum SameSite {
  Strict
  Lax
  None
}
impl Eq for SameSite
impl Show for SameSite

pub struct Uri {
  raw : String
  path : String
  query : Map[String, Array[String]]
  fragment : String?
}
fn Uri::fragment(Self) -> String?
fn Uri::get_query(Self, String) -> String?
fn Uri::get_query_all(Self, String) -> Array[String]
fn Uri::parse(String) -> Self
fn Uri::path(Self) -> String
fn Uri::to_string(Self) -> String

// Type aliases

// Traits

