///|
/// Tests for Path creation and parsing
test "path creates path from string" {
  let fs = InMemoryFS::new()
  let p = path("a/b/c", using_fs=fs)
  inspect(p.to_unix_path(), content="a/b/c")
}

///|
test "path handles empty string" {
  let fs = InMemoryFS::new()
  let p = path("", using_fs=fs)
  inspect(p.to_unix_path(), content="")
}

///|
test "path handles single component" {
  let fs = InMemoryFS::new()
  let p = path("file.txt", using_fs=fs)
  inspect(p.to_unix_path(), content="file.txt")
}

///|
test "path handles root path" {
  let fs = InMemoryFS::new()
  let p = path("/", using_fs=fs)
  inspect(p.to_unix_path(), content="/")
}

///|
/// Tests for path absoluteness
test "path is_absolute returns false for relative path" {
  let fs = InMemoryFS::new()
  let p = path("a/b/c", using_fs=fs)
  inspect(p.is_absolute(), content="false")
}

///|
test "path is_absolute returns true for absolute path" {
  let fs = InMemoryFS::new()
  let p = path("/a/b/c", using_fs=fs)
  inspect(p.is_absolute(), content="true")
}

///|
/// Tests for path components
test "path with multiple components" {
  let fs = InMemoryFS::new()
  let p = path("dir1/dir2/file.txt", using_fs=fs)
  inspect(p.to_unix_path(), content="dir1/dir2/file.txt")
}

///|
test "path with trailing slash" {
  let fs = InMemoryFS::new()
  let p = path("dir1/dir2/", using_fs=fs)
  inspect(p.to_unix_path(), content="dir1/dir2/")
}

///|
/// Tests for Path::parent
test "parent of path with multiple components" {
  let fs = InMemoryFS::new()
  let p = path("a/b/c", using_fs=fs)
  match p.parent() {
    Some(parent) => inspect(parent.to_unix_path(), content="a/b")
    None => abort("Expected parent path")
  }
}

///|
test "parent of single component path returns None" {
  let fs = InMemoryFS::new()
  let p = path("file.txt", using_fs=fs)
  match p.parent() {
    Some(_) => abort("Expected no parent")
    None => inspect(true, content="true")
  }
}

///|
test "parent of empty path returns None" {
  let fs = InMemoryFS::new()
  let p = path("", using_fs=fs)
  match p.parent() {
    Some(_) => abort("Expected no parent")
    None => inspect(true, content="true")
  }
}

///|
/// Tests for Path::resolve_path
test "resolve_path joins two paths" {
  let fs = InMemoryFS::new()
  let p1 = path("a/b", using_fs=fs)
  let p2 = path("c/d", using_fs=fs)
  let result = p1.resolve_path(p2)
  inspect(result.to_unix_path(), content="a/b/c/d")
}

///|
test "resolve_path with empty second path" {
  let fs = InMemoryFS::new()
  let p1 = path("a/b", using_fs=fs)
  let p2 = path("", using_fs=fs)
  let result = p1.resolve_path(p2)
  inspect(result.to_unix_path(), content="a/b/")
}

///|
test "resolve convenience method" {
  let fs = InMemoryFS::new()
  let p = path("a/b", using_fs=fs)
  let result = p.resolve("c")
  inspect(result.to_unix_path(), content="a/b/c")
}

///|
/// Tests for Path::sibling
test "sibling replaces last component" {
  let fs = InMemoryFS::new()
  let p = path("dir1/dir2/foo", using_fs=fs)
  let result = p.sibling("bar")
  inspect(result.to_unix_path(), content="dir1/dir2/bar")
}

///|
test "sibling of path without parent returns new path" {
  let fs = InMemoryFS::new()
  let p = path("foo", using_fs=fs)
  let result = p.sibling("bar")
  inspect(result.to_unix_path(), content="bar")
}

///|
/// Tests for Path::clean
test "clean removes current directory markers" {
  let fs = InMemoryFS::new()
  let p = path("a/./b/./c", using_fs=fs)
  let cleaned = p.clean()
  inspect(cleaned.to_unix_path(), content="a/b/c")
}

///|
test "clean resolves parent directory markers" {
  let fs = InMemoryFS::new()
  let p = path("a/b/../c", using_fs=fs)
  let cleaned = p.clean()
  inspect(cleaned.to_unix_path(), content="a/c")
}

///|
test "clean handles multiple parent markers" {
  let fs = InMemoryFS::new()
  let p = path("a/b/c/../../d", using_fs=fs)
  let cleaned = p.clean()
  inspect(cleaned.to_unix_path(), content="a/d")
}

///|
test "clean removes empty components" {
  let fs = InMemoryFS::new()
  let p = path("a//b///c", using_fs=fs)
  let cleaned = p.clean()
  inspect(cleaned.to_unix_path(), content="a/b/c")
}

///|
test "clean preserves leading parent markers" {
  let fs = InMemoryFS::new()
  let p = path("../a/b", using_fs=fs)
  let cleaned = p.clean()
  inspect(cleaned.to_unix_path(), content="../a/b")
}

///|
test "clean handles only current directory markers" {
  let fs = InMemoryFS::new()
  let p = path("./././.", using_fs=fs)
  let cleaned = p.clean()
  inspect(cleaned.to_unix_path(), content="")
}

///|
/// Tests for Path::starts_with_path
test "starts_with_path returns true for matching prefix" {
  let fs = InMemoryFS::new()
  let p = path("a/b/c/d", using_fs=fs)
  let prefix = path("a/b", using_fs=fs)
  inspect(p.starts_with_path(prefix), content="true")
}

///|
test "starts_with_path returns false for non-matching prefix" {
  let fs = InMemoryFS::new()
  let p = path("a/b/c", using_fs=fs)
  let prefix = path("x/y", using_fs=fs)
  inspect(p.starts_with_path(prefix), content="false")
}

///|
test "starts_with_path returns true for exact match" {
  let fs = InMemoryFS::new()
  let p = path("a/b/c", using_fs=fs)
  let prefix = path("a/b/c", using_fs=fs)
  inspect(p.starts_with_path(prefix), content="true")
}

///|
test "starts_with_path returns false when prefix is longer" {
  let fs = InMemoryFS::new()
  let p = path("a/b", using_fs=fs)
  let prefix = path("a/b/c", using_fs=fs)
  inspect(p.starts_with_path(prefix), content="false")
}

///|
test "starts_with convenience method" {
  let fs = InMemoryFS::new()
  let p = path("a/b/c", using_fs=fs)
  inspect(p.starts_with("a/b"), content="true")
  inspect(p.starts_with("x/y"), content="false")
}

///|
/// Tests for Path::relativize_path
test "relativize_path with child path" {
  let fs = InMemoryFS::new()
  let base = path("a/b", using_fs=fs)
  let target = path("a/b/c/d", using_fs=fs)
  let result = base.relativize_path(target)
  inspect(result.to_unix_path(), content="c/d")
}

///|
test "relativize_path with sibling path" {
  let fs = InMemoryFS::new()
  let base = path("a/b", using_fs=fs)
  let target = path("a/c", using_fs=fs)
  let result = base.relativize_path(target)
  inspect(result.to_unix_path(), content="../c")
}

///|
test "relativize_path with identical paths" {
  let fs = InMemoryFS::new()
  let base = path("a/b/c", using_fs=fs)
  let target = path("a/b/c", using_fs=fs)
  let result = base.relativize_path(target)
  inspect(result.to_unix_path(), content="")
}

///|
test "relativize_path going up multiple levels" {
  let fs = InMemoryFS::new()
  let base = path("a/b/c/d", using_fs=fs)
  let target = path("a/x/y", using_fs=fs)
  let result = base.relativize_path(target)
  inspect(result.to_unix_path(), content="../../../x/y")
}

///|
test "relativize convenience method" {
  let fs = InMemoryFS::new()
  let base = path("a/b", using_fs=fs)
  let result = base.relativize("a/b/c")
  inspect(result.to_unix_path(), content="c")
}

///|
/// Tests for Path equality
test "equal paths are equal" {
  let fs = InMemoryFS::new()
  let p1 = path("a/b/c", using_fs=fs)
  let p2 = path("a/b/c", using_fs=fs)
  inspect(p1 == p2, content="true")
}

///|
test "different paths are not equal" {
  let fs = InMemoryFS::new()
  let p1 = path("a/b/c", using_fs=fs)
  let p2 = path("a/b/d", using_fs=fs)
  inspect(p1 == p2, content="false")
}

///|
test "paths with different lengths are not equal" {
  let fs = InMemoryFS::new()
  let p1 = path("a/b", using_fs=fs)
  let p2 = path("a/b/c", using_fs=fs)
  inspect(p1 == p2, content="false")
}

///|
/// Tests for Path::to_unix_path
test "to_unix_path returns correct string" {
  let fs = InMemoryFS::new()
  let p = path("dir1/dir2/file.txt", using_fs=fs)
  inspect(p.to_unix_path(), content="dir1/dir2/file.txt")
}

///|
test "to_unix_path handles single slash" {
  let fs = InMemoryFS::new()
  let p = path("/", using_fs=fs)
  inspect(p.to_unix_path(), content="/")
}

///|
/// Tests for Show trait
test "path Show implementation" {
  let fs = InMemoryFS::new()
  let p = path("a/b/c", using_fs=fs)
  inspect(p, content="a/b/c")
}

///|
test "path Show handles empty path" {
  let fs = InMemoryFS::new()
  let p = path("", using_fs=fs)
  inspect(p, content="")
}
