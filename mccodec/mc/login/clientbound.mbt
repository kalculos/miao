///|
/// Disconnect (login) packet (0x00)
/// Sent when the server disconnects a client during login
struct DisconnectLoginS2C {
  reason : String // JSON Text Component, TODO: Component type
}

///|
impl @mc.Packet for DisconnectLoginS2C with clientbound(self) {
  true
}

///|
impl @mc.Packet for DisconnectLoginS2C with serialize(
  self,
  buf : &@bytebuf.ByteBuf,
) {
  @types.write_string(buf, self.reason)
}

///|
impl @mc.Packet for DisconnectLoginS2C with deserialize(buf : &@bytebuf.ByteBuf) {
  let reason_str = @types.read_string(buf)
  { reason: reason_str }
}

///|
/// Encryption Request packet (0x01)
/// Sent by the server to request encryption handshake
struct EncryptionRequestS2C {
  server_id : String // Always empty in vanilla (20 chars max)
  public_key : FixedArray[Byte] // Server's public key, in bytes
  verify_token : FixedArray[Byte] // Random bytes generated by server
  should_authenticate : Bool // Whether to authenticate through Mojang servers
}

///|
impl @mc.Packet for EncryptionRequestS2C with clientbound(self) {
  true
}

///|
impl @mc.Packet for EncryptionRequestS2C with serialize(
  self,
  buf : &@bytebuf.ByteBuf,
) {
  @types.write_string(buf, self.server_id)
  @types.write_prefix_array(
    buf,
    self.public_key,
    @bytebuf.ByteWriter::write_byte,
  )
  @types.write_prefix_array(
    buf,
    self.verify_token,
    @bytebuf.ByteWriter::write_byte,
  )
  @types.write_bool(buf, self.should_authenticate)
}

///|
impl @mc.Packet for EncryptionRequestS2C with deserialize(
  buf : &@bytebuf.ByteBuf,
) {
  let server_id = @types.read_string(buf)
  let public_key = @types.read_prefix_array(buf, b => b.read_byte().unwrap_or(0))
  let verify_token = @types.read_prefix_array(buf, b => b
    .read_byte()
    .unwrap_or(0))
  let should_authenticate = @types.read_bool(buf)
  { server_id, public_key, verify_token, should_authenticate }
}

///|
/// Login Success packet (0x02)
/// Sent when login is successful, switches to configuration state
struct LoginSuccessS2C {
  profile : @types.GameProfile // Game Profile (contains UUID and username)
}

///|
impl @mc.Packet for LoginSuccessS2C with clientbound(self) {
  true
}

///|
impl @mc.Packet for LoginSuccessS2C with serialize(
  self,
  buf : &@bytebuf.ByteBuf,
) {
  @types.write_game_profile(buf, self.profile)
}

///|
impl @mc.Packet for LoginSuccessS2C with deserialize(buf : &@bytebuf.ByteBuf) {
  let profile = @types.read_game_profile(buf)
  { profile, }
}

///|
/// Set Compression packet (0x03)
/// Enables compression for all following packets (optional)
struct SetCompressionS2C {
  threshold : Int // Maximum packet size before compression
}

///|
impl @mc.Packet for SetCompressionS2C with clientbound(self) {
  true
}

///|
impl @mc.Packet for SetCompressionS2C with serialize(
  self,
  buf : &@bytebuf.ByteBuf,
) {
  @types.write_varint(buf, self.threshold)
}

///|
impl @mc.Packet for SetCompressionS2C with deserialize(buf : &@bytebuf.ByteBuf) {
  let threshold = @types.read_varint(buf)
  { threshold, }
}

///|
/// Login Plugin Request packet (0x04)
/// Custom handshaking flow for plugin messages
struct LoginPluginRequestS2C {
  message_id : Int // Unique to the connection
  channel : String // Plugin channel identifier, TODO: Identifier type
  data : Array[Byte] // Plugin data
}

///|
impl @mc.Packet for LoginPluginRequestS2C with clientbound(self) {
  true
}

///|
impl @mc.Packet for LoginPluginRequestS2C with serialize(
  self,
  buf : &@bytebuf.ByteBuf,
) {
  @types.write_varint(buf, self.message_id)
  @types.write_string(buf, self.channel)
  buf.write_bytes(Bytes::from_array(self.data))
}

///|
impl @mc.Packet for LoginPluginRequestS2C with deserialize(
  buf : &@bytebuf.ByteBuf,
) {
  let message_id = @types.read_varint(buf)
  let channel = @types.read_string(buf)
  let data = buf.read_bytes(buf.remaining()).unwrap().to_array()
  { message_id, channel, data }
}

///|
/// Cookie Request (login) packet (0x05)
/// Requests a previously stored cookie
struct CookieRequestLoginS2C {
  key : String // Identifier of the cookie, TODO: Identifier type
}

///|
impl @mc.Packet for CookieRequestLoginS2C with clientbound(self) {
  true
}

///|
impl @mc.Packet for CookieRequestLoginS2C with serialize(
  self,
  buf : &@bytebuf.ByteBuf,
) {
  @types.write_string(buf, self.key)
}

///|
impl @mc.Packet for CookieRequestLoginS2C with deserialize(
  buf : &@bytebuf.ByteBuf,
) {
  let key = @types.read_string(buf)
  { key, }
}
